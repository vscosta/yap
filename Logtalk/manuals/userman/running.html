<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet type="text/css" href="../styles.css" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
	<title>Logtalk user manual: running and debugging Logtalk programs</title>
	<link rel="stylesheet" href="../styles.css" type="text/css" />
</head>

<body>

<div class="navtop">
<a href="../index.html">contents</a> &gt; <a href="index.html">user manual</a>
</div>

<h1>Running and debugging Logtalk programs</h1>

<h2>Running a Logtalk session<a name="running"></a></h2>

<p>
We run Logtalk inside a normal Prolog session, after loading the needed files. Logtalk extends but does not modify your Prolog compiler. We can freely mix Prolog queries with the sending of messages and our programs can be made of both normal Prolog clauses and object definitions.
</p>

<h3>Starting Logtalk<a name="starting"></a></h3>

<p>
To start a Logtalk session just:
</p>
<ol>
	<li>Start Prolog.</li>
	<li>Load the appropriate configuration file for your compiler. Configuration files for most common Prolog compilers can be found in the <code>configs</code> subdirectory.</li>
	<li>Load the Logtalk compiler/preprocessor and runtime files contained in the <code>compiler</code> subdirectory.</li>
</ol>
<p>
Note that the both configuration files and compiler/preprocessor files are Prolog source files. The predicate called to load (and compile) them depends on your Prolog compiler. In case of doubt, consult your Prolog compiler reference manual or take a look at the definition of the predicate <code>'$lgt_load_prolog_code'/1</code> in the corresponding configuration file.
</p>

<h3>Compiling and loading your programs<a name="compiling"></a></h3>

<p>
Your programs will be made of source files containing your objects, protocols and categories. After changing the Prolog working directory to the one containing your files, you can compile them to disk by calling the Logtalk built-in predicate  
<a title="Consult reference manual" href="../refman/builtins/logtalk_compile1.html"><code>logtalk_compile/1</code></a>:
</p>
<pre>
    | ?- logtalk_compile([source_file1, source_file2, ...]).
</pre>
<p>
This predicate runs the preprocessor on each argument file and, if no fatal errors are found, outputs Prolog source files that can then be consulted or compiled in the usual way by your Prolog compiler. Note that the predicate argument must be a list of entity names, not file names (or paths).
</p>
<p>
To compile to disk and also load into memory the source files we can use the Logtalk built-in predicate <a title="Consult reference manual" href="../refman/builtins/logtalk_load1.html"><code>logtalk_load/1</code></a>:
</p>
<pre>
    | ?- logtalk_load([source_file1, source_file2, ...]).
</pre>
<p>
This predicate works in the same way of the predicate <code>logtalk_compile/1</code> but also loads the compiled files to memory. 
</p>
<p>
Both predicates expect an entity name or a list of entity names (atoms) as an argument. The Logtalk source file name extension, as defined in the configuration file, should be omitted.
</p>
<p>
If you have more than a few source files then you may want to use a loader utility file containing the calls to the <code>logtalk_load/1</code> predicate (see the description above). Consulting or compiling the loader file will then compile and load all your Logtalk entities into memory.
</p>

<h3>Compiler option flags<a name="options"></a></h3>

<p>
The <a title="Consult reference manual" href="../refman/builtins/logtalk_load1.html"><code>logtalk_load/1</code></a> and <a title="Consult reference manual" href="../refman/builtins/logtalk_compile1.html"><code>logtalk_compile/1</code></a> always use the set of default compiler option flags specified in the Logtalk configuration files. Although the default options cover the usual cases, you may want to use a different set of options while compiling or loading some of your Logtalk source files. This can be accomplished by using the <a title="Consult reference manual" href="../refman/builtins/logtalk_load2.html"><code>logtalk_load/2</code></a> or the <a title="Consult reference manual" href="../refman/builtins/logtalk_compile2.html"><code>logtalk_compile/2</code></a> built-in predicates. These two predicates accept a list of options affecting how a Logtalk source file is compiled and loaded:
</p>
<pre>
    | ?- logtalk_compile(Files, Options).
</pre>
<p>
or:
</p>
<pre>
    | ?- logtalk_load(Files, Options).
</pre>
<p>
In fact, the <code>logtalk_load/1</code> and <code>logtalk_compile/1</code> predicates are just shortcuts to the extended versions called with the default compiler options.
</p>
<p>
You can use the following options:
</p>
<blockquote>
<dl>
	<dt><code>unknown(Option)</code></dt>
		<dd>Controls the unknown entity warnings, resulting from loading an entity that references some other entity that is not currently loaded. Possible option values are <code>warning</code> (the usual default) and <code>silent</code>.</dd>
</dl>
<dl>
	<dt><code>singletons(Option)</code></dt>
		<dd>Controls the singleton variable warnings. Possible option values are <code>warning</code> (the usual default) and <code>silent</code> (not recommended).</dd>
</dl>
<dl>
	<dt><code>underscore_vars(Option)</code></dt>
		<dd>Controls the interpretation of variables that start with an underscore (excluding the anonymous variable) that occur once in a term as either don't care variables or singleton variables. Possible option values are <code>dont_care</code> and <code>singletons</code> (the usual default). Note that, depending on your Prolog compiler, the <code>read_term/3</code> built-in predicate may report variables that start with an underscore as singleton variables. There is no standard behavior, hence this option.</dd>
</dl>
<dl>
	<dt><code>misspelt(Option)</code></dt>
		<dd>Controls the misspelt calls warnings. Possible option values are <code>warning</code> (the usual default) and <code>silent</code> (not recommended).</dd>
</dl>
<dl>
	<dt><code>lgtredef(Option)</code></dt>
		<dd>Controls the Logtalk built-in predicates redefinition warnings. Possible option values are <code>warning</code> (the usual default) and <code>silent</code>.</dd>
</dl>
<dl>
	<dt><code>plredef(Option)</code></dt>
		<dd>Controls the Prolog built-in predicates redefinition warnings. Possible option values are <code>warning</code> (can be very verbose if your code redefines a lot of Prolog built-in predicates) and <code>silent</code> (the usual default).</dd>
</dl>
<dl>
	<dt><code>portability(Option)</code></dt>
		<dd>Controls the calling of non-ISO defined built-in predicates warnings. Possible option values are <code>warning</code> and <code>silent</code> (the usual default).</dd>
</dl>
<dl>
	<dt><code>xml(Option)</code></dt>
		<dd>Controls the automatic generation of documenting files in XML format. Possible option values are <code>on</code> (the usual default) and <code>off</code>.</dd>
</dl>
<dl>
	<dt><code>xmlspec(Option)</code></dt>
		<dd>Defines the XML documenting files specification format. Possible option values are <code>dtd</code> (for the DTD specification; the usual default) and <code>xsd</code> (for the XML Schema specification).</dd>
</dl>
<dl>
	<dt><code>doctype(Option)</code></dt>
		<dd>Sets the DOCTYPE reference in the automatically generated XML documenting files. The default value is <code>local</code>, that is, the DOCTYPE reference points to a local DTD or XSD file (respectively, <code>logtalk.dtd</code> or <code>logtalk.xsd</code>), residing in the same directory as the XML file. Other possible values are <code>web</code> (DOCTYPE reference points to an web location, either <code>http://www.logtalk.org/xml/1.0/logtalk.dtd</code> or <code>http://www.logtalk.org/xml/1.0/logtalk.xsd</code>) and <code>standalone</code> (no DOCTYPE reference in the XML documenting files).</dd>
</dl>
<dl>
	<dt><code>xsl(File)</code></dt>
		<dd>Sets the XSLT file to be used with the automatically generated XML documenting files. The default value is <code>lgtxml.xsl</code>.</dd>
</dl>
<dl>
	<dt><code>report(Option)</code></dt>
		<dd>Controls reporting of each compiled or loaded object, category, or protocol (including compilation and loading warnings). Possible option values are <code>on</code> (the usual default) and <code>off</code> (silent compilation and loading).</dd>
</dl>
<dl>
	<dt><code>iso_initialization_dir(Option)</code></dt>
		<dd>Controls the use of the <code>initialization/1</code> directive in the Logtalk generated Prolog code. Possible option values are <code>true</code> (if the Prolog compiler supports the ISO definition of the directive) and <code>false</code> (if the Prolog compiler either does not implement the directive or if the implementation does not conform to the ISO standard).</dd>
</dl>
<dl>
	<dt><code>smart_compilation(Option)</code></dt>
		<dd>Controls the use of smart compilation of source files to avoid recompiling files that are unchanged since the last time they are compiled. Possible option values are <code>on</code> and <code>off</code> (the usual default).</dd>
</dl>
<dl>
	<dt><code>code_prefix(Option)</code></dt>
		<dd>Enables the definition of prefix for all functors of Logtalk generated Prolog code. Option value must be an atom. Default value is ''.</dd>
</dl>
<dl>
	<dt><code>debug(Option)</code></dt>
		<dd>Controls the compilation of source files in debug mode. Possible option values are <code>on</code> and <code>off</code> (the usual default).</dd>
</dl>
</blockquote>
<p>
We may also change the default options values from the ones loaded from the config file by using the <a title="Consult reference manual" href="../refman/builtins/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a> built-in predicate. For example:
</p>
<pre>
    | ?- set_logtalk_flag(xml, off).
</pre>
<p>
The current values of the default flags can be enumerated using the <a title="Consult reference manual" href="../refman/builtins/current_logtalk_flag2.html"><code>current_logtalk_flag/2</code></a> built-in predicate:
</p>
<pre>
    | ?- current_logtalk_flag(xml, Value).

    Value = off
    yes
</pre>

<h3>Smart compilation of source files<a name="smart"></a></h3>

<p>
If the Prolog compiler that you are using supports retrieving  of file modification dates, then you can turn on smart compilation of source files to avoid recompiling files that have not been modified since last compilation.
</p>
<p>
Smart compilation of source files is usually off by default. You can turn it on by changing the default flag value in the configuration file, by using the corresponding compiler option with the compiling and loading built-in predicates, or, for the remaining of a working session, by using the call:
</p>
<pre>
    | ?- set_logtalk_flag(smart_compilation, on).
</pre>
<p>
Some caveats that you should be aware. First, some warnings that might be produced when compiling a source file will not show up if the corresponding object file is up-to-date because the source file is not being (re)compiled. Second, if you are using several Prolog compilers with Logtalk, be sure to perform the first compilation of your source files with smart compilation turned off: the intermediate Prolog files generated by the Logtalk preprocessor may be not compatible across Prolog compilers or even for the same Prolog compiler across operating systems (due to different end-of-line characters).
</p>

<h2>Using Logtalk for batch processing<a name="batch"></a></h2>

<p>
If you use Logtalk for batch processing, you probably want to supress most, if not all, banners, messages, and warnings that are normally printed by the system.
</p>
<p>
To supress printing of the Logtalk startup banner and default flags, set the option <code>startup_message</code> in the config file that you are using to <code>none</code>.
</p>
<p>
To supress printing of compiling and loading messages (including compiling warnings but not error messages), turn off the option <code>report</code> in the used config file.
</p>

<h2>Debugging Logtalk programs<a name="debugging"></a></h2>

<p>
Logtalk defines a built-in pseudo-object named <code>debugger</code>, which implements debugging features similar to those found on most Prolog compilers. However, there are some differences between the usual implementation of Prolog debuggers and the current implementation of the Logtalk debugger that you should be aware. First, unlikely most Prolog debuggers, the Logtalk debugger is not implemented as a meta-interpreter. This translates to a different, although similar, set of debugging features with some limitations when compared with Prolog debuggers. Second, debugging is only possible for objects compiled in debug mode. When compiling an object in this mode, Logtalk keeps each  clause goal in both source form and compiled form in order to allow tracing of the goal execution. Third, implementation of spy points allows the user to specify the execution context for entering the debugger. This feature is a consequence of the encapsulation of predicates inside objects.

<h3>Compiling objects in debug mode<a name="debugmode"></a></h3>

Compilation of source files in debug mode is controlled by the compiler flag <code>debug</code>. The default value for this flag, usually <code>off</code>, is defined in the config files. Its value may be changed at runtime by writing:
</p>
<pre>
    | ?- set_logtalk_flag(debug, on).

    yes
</pre>
<p>
In alternative, if we want to compile only some objects in debug mode, we may instead write:
</p>
<pre>
    | ?- logtalk_load([file1, file2, ...], [debug(on)]).
</pre>
<p>
The compiler flag <code>smart_compilation</code> is automatically turned off whenever the debug flag is turned on at runtime. This is necessary because debug code would not be generated for files previously compiled in normal mode if there is no changes to the source files. However, note that you should be carefull to not turn both flags on at the same time in a config file.
</p>

<h3>Logtalk Procedure Box model<a name="boxmodel"></a></h3>

<p>
Logtalk uses a <em>Procedure Box model</em> similar to those found on most Prolog compilers. The traditional Prolog procedure box model uses four ports (<em>call</em>, <em>exit</em>, <em>redo</em>, and <em>fail</em>) for describing control flow when a predicate clause is used during program execution: 
</p>
<blockquote>
<dl>
	<dt><code>call</code></dt>
		<dd>predicate call</dd>
	<dt><code>exit</code></dt>
		<dd>success of a predicate call</dd>
	<dt><code>redo</code></dt>
		<dd>backtraking into a predicate</dd>
	<dt><code>fail</code></dt>
		<dd>failure of a predicate call</dd>
</dl>
</blockquote>
<p>
Logtalk, as found on some recent Prolog compilers, adds a port for dealing with exceptions thrown when calling a predicate:
</p>
<blockquote>
<dl>
	<dt><code>exception</code></dt>
		<dd>predicate call throws an exception</dd>
</dl>
</blockquote>
<p>
In addition to the ports described above, Logtalk adds two more ports, <em>fact</em> and <em>rule</em>, which show the result of the unification of a goal with, respectively, a fact and a rule head:
</p>
<blockquote>
<dl>
	<dt><code>fact</code></dt>
		<dd>unification success between a goal and a fact</dd>
	<dt><code>rule</code></dt>
		<dd>unification success between a goal and a rule head</dd>
</dl>
</blockquote>
<p>
The user may define for which ports the debugger should pause for user interaction by specifiying a list of leashed ports. For example:
</p>
<pre>
    | ?- debugger::leash([call, exit, fail]).
</pre>
<p>
Alternatively, the user may use an atom abbreviation for a pre-defined set of ports. For example:
</p>
<pre>
    | ?- debugger::leash(loose).
</pre>
</p>
<p>
The abbreviations defined in Logtalk are similar to those defined on some Prolog compilers:
</p>
<blockquote>
<dl>
	<dt><code>none</code></dt>
		<dd><code>[]</code></dd>
	<dt><code>loose</code></dt>
		<dd><code>[fact, rule, call]</code></dd>
	<dt><code>half</code></dt>
		<dd><code>[fact, rule, call, redo]</code></dd>
	<dt><code>tight</code></dt>
		<dd><code>[fact, rule, call, redo, fail, exception]</code></dd>
	<dt><code>full</code></dt>
		<dd><code>[fact, rule, call, exit, redo, fail, exception]</code></dd>
</dl>
</blockquote>

<h3>Defining spy points<a name="spypoints"></a></h3>

<p>
Logtalk spy points can be defined by simply stating which predicates should be spied, as in most Prolog debuggers, or by fully specifying the context for activating a spy point. 

<h4>Defining predicate spy points<a name="spypoints"></a></h4>

Predicate spy points are specified using the method <code>spy/1</code>. The argument can be either a predicate indicator (<code>Functor/Arity</code>) or a list of predicate indicators. For example:
<pre>
    | ?- debugger::spy(foo/2).
    
    Spy points set.
    yes

    | ?- debugger::spy([foo/4, bar/1]).
    
    Spy points set.
    yes
</pre>
Predicate spy points can be removed by using the method <code>nospy/1</code>. The argument can be a predicate indicator, a list of predicate indicators, or a non-instantiated variable in which case all predicate spy points will be removed. For example:
<pre>
    | ?- debugger::nospy(_).
    
    All matching predicate spy points removed.
    yes
</pre>

<h4>Defining context spy points<a name="spypoints"></a></h4>

A context spy point is a term describing a message execution context and a goal:
</p>
<pre>
    (Sender, This, Self, Goal)
</pre>
<p>
The debugger is evoked whenever the execution context is true and when the spy point goal unifies with the goal currently being executed. Variable bindings resulting from the unification between the current goal and the goal argument are discarded. The user may establish any number of context spy points as necessary. For example, in order to call the debugger whenever a predicate defined on an object named <code>foo</code> is called we may define the following spy point:
</p>
<pre>
    | ?- debugger::spy(_, foo, _, _).
    
    Spy point set.
    yes
</pre>
<p>
For example, we can spy all calls to a <code>foo/2</code> predicate by setting the condition:
</p>
<pre>
    | ?- debugger::spy(_, _, _, foo(_, _)).
    
    Spy point set.
    yes
</pre>
<p>
The method <code>nospy/4</code> may be used to remove all matching spy points. For example, the call: 
</p>
<pre>
    | ?- debugger::nospy(_, _, foo, _).
    
    All matching context spy points removed.
    yes
</pre>
<p>
will remove all context spy points where the value of <em>Self</em> matches the name <code>foo</code>.

<h4>Removing all spy points<a name="nospyall"></a></h4>

We may remove all predicate and context spy points by using the method <code>nospyall/0</code>:
</p>
<pre>
    | ?- debugger::nospyall.
    
    All predicate spy points removed.
    All context spy points removed.
    yes
</pre>

<h3>Tracing program execution<a name="trace"></a></h3>

<p>
Logtalk allows tracing of execution for all objects compiled in debug mode. To start the debugger in trace mode, write:
</p>
<pre>
    | ?- debugger::trace.

    yes
</pre>
<p>
Note that, when tracing, spy points will be ignored. While tracing, the debugger will pause for user input at each leashed port.
</p>
<p>
To stop tracing and turning off the debugger, write:
</p>
<pre>
    | ?- debugger::notrace.

    yes
</pre>


<h3>Debugging using spy points<a name="debug"></a></h3>

Tracing a program execution may generate large amounts of debugging data. Debugging using spy points allows the user to concentrate its attention in specific points of its code. To start a debugging session using spy points, write:
<pre>
    | ?- debugger::debug.

    yes
</pre>
<p>
At the beginning of a port description, the debugger will print a <code>+</code> or a <code>*</code> before the current goal if there is, respectively, a predicate spy point or a context spy point defined.
</p>
<p>
To stop the debugger, write:
</p>
<pre>
    | ?- debugger::nodebug.

    yes
</pre>
<p>
Note that stopping the debugger does not remove any defined spy points.
</p>

<h3>Debugging commands<a name="commands"></a></h3>

<p>
The debugger pauses at leashed posts when tracing or when finding a spy point for user interaction. The commands available are as follows:
</p>
<blockquote>
<dl>
	<dt><code>c</code> &mdash; creep</dt>
		<dd>go on; you may use the spacebar in alternative</dd>
	<dt><code>l</code> &mdash; leep</dt>
		<dd>continues execution until the next spy point is found</dd>
	<dt><code>s</code> &mdash; skip</dt>
		<dd>skips debugging for the current goal; only valid at call and redo ports</dd>
	<dt><code>f</code> &mdash; fail</dt>
		<dd>forces backtracking</dd>
	<dt><code>n</code> &mdash; nodebug</dt>
		<dd>turns off debugging</dd>
	<dt><code>@</code> &mdash; command</dt>
		<dd>reads and executes a query</dd>
	<dt><code>b</code> &mdash; break</dt>
		<dd>suspends execution and starts new interpreter; type <code>end_of_file</code> to terminate</dd>
	<dt><code>a</code> &mdash; abort</dt>
		<dd>returns to top level interpreter</dd>
	<dt><code>d</code> &mdash; display</dt>
		<dd>writes current goal without using operator notation</dd>
	<dt><code>x</code> &mdash; context</dt>
		<dd>prints execution context</dd>
	<dt><code>e</code> &mdash; exception</dt>
		<dd>prints exception term thrown by current goal</dd>
	<dt><code>=</code> &mdash; debugging</dt>
		<dd>prints debugging information</dd>
	<dt><code>*</code> &mdash; add</dt>
		<dd>adds a context spy point for current goal</dd>
	<dt><code>+</code> &mdash; add</dt>
		<dd>adds a predicate spy point for current goal</dd>
	<dt><code>-</code> &mdash; remove</dt>
		<dd>removes a predicate spy point for current goal</dd>
	<dt><code>h</code> &mdash; help</dt>
		<dd>prints list of command options; <code>?</code> can be used in alternative</dd>
</dl>
</blockquote>

<div class="navbottom">
<a href="installing.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="programming.html">next</a>
</div>

<div class="copyright">
Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://www.logtalk.org">Logtalk.org</a>
</div>

<div class="footer">
<p><span class="bleft"><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span><span class="bright">Last updated on: June 11, 2004</span></p>
</div>
</body>
</html>
